# 研究Newtonsoft.json和ioc框架就能完全掌握反射和程序集知识









获取指定Type的默认值

```csharp
public static object DefaultForType(Type targetType)  
{  
    return targetType.IsValueType ? Activator.CreateInstance(targetType) : null;  
}
```

```csharp
struct Point
{
    public int m_x, m_y;
    Point()
    {
        m_x = m_y = 5;
    }
}
```

结果却是编译出错了：

> 结构不能包含显式的无参数构造函数

原因是：**C#不允许值类型自定义无参构造函数**。  
但其实CLR中是允许的。那C#为什么不允许呢？当然是有原因的啦。  
还是回到创建变量时的指令，值类型是使用initobj指令创建的，该指令只完成值类型的初始化，并不调用构造函数，也就是说**即使值类型有构造函数，也不会自动调用。**  
就像上面Point的无参构造函数，我们预想的是xy值为5，若结果创建对象后还是0，会让程序猿感觉很困惑，所以**C#默认禁止了值类型创建无参构造函数。**  
但C#是允许创建有参构造函数的，但是有一点要注意，必须在构造函数中为所有的字段设定值，否则编译时会报如下错误。

简单的获取某变量类型的默认值

在c#中为我们提供了default()，但是default的参数是具体的类名，

如何根据变量类型的Type获取默认值Code如下：

1 public static object DefaultForType(Type targetType)   
3 {  
5  return targetType.IsValueType ? Activator.CreateInstance(targetType) : null;    
7 }  
8 

 这句话很简单，使我们对于c#类型值类型和引用类型的很好理解下得出的。

在c#中我们的类型分为值类型和引用类型。从概念上看，值类型直接存储其值，而引用类型存储对其值的引用。这两种类型存储在内存的不同地方（堆和栈）。





# 程序集简介

程序集和程序集文件是两种不同的概念，一个程序集可以有多个程序集文件。一个程序集可以分成多个模块，一个模块就是一个程序集文件。模块的好处就是用到哪个模块就只加载哪个模块，可以提高程序的性能。但是一般还是让一个程序集只有一个模块，只有一个程序集文件，称为单文件程序集。Visual Studio只支持生成单文件程序集。

程序集中包含：清单(Manifest)，元数据，资源文件。

清单：名称，版本，区域，公钥，引用了哪些程序集，资源信息(不带路径，只是在.Resources中的相关信息)。

元数据：描述数据的数据，更适合叫做类型元数据。里面包含定义的Class。

程序集资源：.Resources二进制文件。

# 强名称程序集

通过嵌入公钥并使用私钥签名，可以生成强名称（strong name）的程序集。强名称程序集由4部分进行标识：名称、版本、区域性和公钥。与之相对的，我们可以把没有嵌入公钥和使用私钥签名的程序集称之为弱名称（weak name）程序集。强名称程序集与弱名称程序集相比，有以下特点：

- 强名称程序集可以保证唯一性。公/私密钥对是由发行者自行生成的，是唯一的，保证了程序集的标识不会重复。
- 强名称程序集可以防篡改。强类型程序集使用私钥对自己进行了签名，这样在被加载时可以检查程序集是否被修改。
- 强名称程序集可以防止被仿冒
- 强名称程序集可以实施版本策略。对于弱名称程序集，引用它的程序不会关心它的版本，而对于强类型的程序集来说，引用它的程序会被绑定到特定版本的程序集上，如果使用新版本的强名称程序集替换旧版本，会导致程序无法运行。
- 强名称程序集可以部署到GAC中。弱名称程序集无法部署到此处。不同版本的相同程序集还可以同时存在于GAC中。
- 强名称程序集只能引用强名称程序集。弱名称程序集可以引用强名称程序集，也可以引用弱名称程序集，但强名称程序集只能引用强名称程序集。

# 生成强名称程序集的原理

制造商发布dll时，对dll进行哈希运算得到哈希码，再使用私钥加密哈希码得到密文，嵌入到dll。

客户机拿到dll，对dll进行哈希运算得到哈希码A，再用嵌入到dll中的公钥解密密文拿到制造商发布的哈希码B，两个哈希码进行比对，完全一致则正常使用dll，否则CLR报错。

1. 唯一性：public key token是唯一的
2. 防篡改：如果dll被篡改，客户机拿到的哈希码与密文解密后得到的哈希码肯定不一样
3. 防仿冒：别人只能知道公钥，但是无法得到私钥嵌入密文。

GAC（特殊文件夹，不仅仅靠文件名来区分文件）

1. 一个强名称程序集的唯一性由 程序集名称，版本号，区域性，公钥标记4部分组成。公钥是唯一的。
2. 仿冒公司不知道私钥，无法加密哈希码，客户机虽然拿到正确的公钥，但是无法解密密文。
3. 如果dll被注入恶意代码，客户机拿到的哈希码和嵌入的密文哈希码绝对不会相同。

# 制作一个强名称程序集的步骤

安装Visual Studio，会自动安装sn.exe，它可以生成公钥/私钥对。

sn -k D:\TongfuInn.snk

snk是公钥/密钥对，里面既包含公钥，又包含私钥。

在项目属性中勾选Sign the assembly

编译时，Visual Studio会为我们完成两件事：

1. 公钥标记，即把程序集的public key token设置成公钥。程序集具备了唯一性。
2. 私钥签名，嵌入dll的哈希密文，让程序集无法被篡改。

![image.png](https://i.loli.net/2020/04/12/pJjifublNekUL2A.png)

## 查看Strong Name Assembly的公钥

sn -Tp target.dll

如果有程序引用了强名称程序集，会记录由以下内容标识的程序集：

MyStrongNameAssembly, Version=1.0.3087.28686, Culture=neutral, PublicKeyToken=337642649f453c2c

这些内容唯一的标识了一个强名称程序集，由于公钥太长，这里只引用了公钥标记。当程序运行时，CLR 会根据这些内容按照查找dll规则去搜寻程序集，只有完全匹配的程序集才会被加载，即便是版本的细微差别都不会忽略。如果没有找到，或者找到的程序集不匹配，都会产生异常。

# 为项目添加引用

1.同一解决方案下，就添加项目，让其他项目引用

2.在解决方案下新建referencedll文件夹，把要引用的dll都放到该文件夹下面，添加dll时从这里面寻找。

dll的Copy Local属性设置成true，编译时，会从Path属性指向的路径，拷贝一份到生成目录。

Copy Local属性设置成false，编译时，不会拷贝到生成目录。运行时，会因为找不到程序集而报错。

一般我们把Copy Local设置成true，除非我们指定dll的搜索路径，才会设置成false。

